// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Knot(params KnotWhereUniqueInput) *KnotExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"KnotWhereUniqueInput!", "Knot"},
		"knot",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExec{ret}
}

type KnotsParams struct {
	Where   *KnotWhereInput   `json:"where,omitempty"`
	OrderBy *KnotOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Knots(params *KnotsParams) *KnotExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"KnotWhereInput", "KnotOrderByInput", "Knot"},
		"knots",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExecArray{ret}
}

type KnotsConnectionParams struct {
	Where   *KnotWhereInput   `json:"where,omitempty"`
	OrderBy *KnotOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *KnotConnection) Nodes() []Knot {
	var nodes []Knot
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *KnotConnection) NodesPtr() []*Knot {
	var nodes []*Knot
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) KnotsConnection(params *KnotsConnectionParams) *KnotConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"KnotWhereInput", "KnotOrderByInput", "Knot"},
		"knotsConnection",
		[]string{"edges", "pageInfo"})

	return &KnotConnectionExec{ret}
}

func (client *Client) Link(params LinkWhereUniqueInput) *LinkExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LinkWhereUniqueInput!", "Link"},
		"link",
		[]string{"id", "source", "target"})

	return &LinkExec{ret}
}

type LinksParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Links(params *LinksParams) *LinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "Link"},
		"links",
		[]string{"id", "source", "target"})

	return &LinkExecArray{ret}
}

type LinksConnectionParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *LinkConnection) Nodes() []Link {
	var nodes []Link
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *LinkConnection) NodesPtr() []*Link {
	var nodes []*Link
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) LinksConnection(params *LinksConnectionParams) *LinkConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "Link"},
		"linksConnection",
		[]string{"edges", "pageInfo"})

	return &LinkConnectionExec{ret}
}

func (client *Client) LinkedApp(params LinkedAppWhereUniqueInput) *LinkedAppExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LinkedAppWhereUniqueInput!", "LinkedApp"},
		"linkedApp",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExec{ret}
}

type LinkedAppsParams struct {
	Where   *LinkedAppWhereInput   `json:"where,omitempty"`
	OrderBy *LinkedAppOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) LinkedApps(params *LinkedAppsParams) *LinkedAppExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LinkedAppWhereInput", "LinkedAppOrderByInput", "LinkedApp"},
		"linkedApps",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExecArray{ret}
}

type LinkedAppsConnectionParams struct {
	Where   *LinkedAppWhereInput   `json:"where,omitempty"`
	OrderBy *LinkedAppOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *LinkedAppConnection) Nodes() []LinkedApp {
	var nodes []LinkedApp
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *LinkedAppConnection) NodesPtr() []*LinkedApp {
	var nodes []*LinkedApp
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) LinkedAppsConnection(params *LinkedAppsConnectionParams) *LinkedAppConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LinkedAppWhereInput", "LinkedAppOrderByInput", "LinkedApp"},
		"linkedAppsConnection",
		[]string{"edges", "pageInfo"})

	return &LinkedAppConnectionExec{ret}
}

func (client *Client) Map(params MapWhereUniqueInput) *MapExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"MapWhereUniqueInput!", "Map"},
		"map",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

type MapsParams struct {
	Where   *MapWhereInput   `json:"where,omitempty"`
	OrderBy *MapOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) Maps(params *MapsParams) *MapExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MapWhereInput", "MapOrderByInput", "Map"},
		"maps",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExecArray{ret}
}

type MapsConnectionParams struct {
	Where   *MapWhereInput   `json:"where,omitempty"`
	OrderBy *MapOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *MapConnection) Nodes() []Map {
	var nodes []Map
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *MapConnection) NodesPtr() []*Map {
	var nodes []*Map
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) MapsConnection(params *MapsConnectionParams) *MapConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MapWhereInput", "MapOrderByInput", "Map"},
		"mapsConnection",
		[]string{"edges", "pageInfo"})

	return &MapConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) CreateKnot(params KnotCreateInput) *KnotExec {
	ret := client.Client.Create(
		params,
		[2]string{"KnotCreateInput!", "Knot"},
		"createKnot",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExec{ret}
}

type KnotUpdateParams struct {
	Data  KnotUpdateInput      `json:"data"`
	Where KnotWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateKnot(params KnotUpdateParams) *KnotExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"KnotUpdateInput!", "KnotWhereUniqueInput!", "Knot"},
		"updateKnot",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExec{ret}
}

type KnotUpdateManyParams struct {
	Data  KnotUpdateManyMutationInput `json:"data"`
	Where *KnotWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyKnots(params KnotUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"KnotUpdateManyMutationInput!", "KnotWhereInput"},
		"updateManyKnots")
	return &BatchPayloadExec{exec}
}

type KnotUpsertParams struct {
	Where  KnotWhereUniqueInput `json:"where"`
	Create KnotCreateInput      `json:"create"`
	Update KnotUpdateInput      `json:"update"`
}

func (client *Client) UpsertKnot(params KnotUpsertParams) *KnotExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"KnotWhereUniqueInput!", "KnotCreateInput!", "KnotUpdateInput!", "Knot"},
		"upsertKnot",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExec{ret}
}

func (client *Client) DeleteKnot(params KnotWhereUniqueInput) *KnotExec {
	ret := client.Client.Delete(
		params,
		[2]string{"KnotWhereUniqueInput!", "Knot"},
		"deleteKnot",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExec{ret}
}

func (client *Client) DeleteManyKnots(params *KnotWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "KnotWhereInput", "deleteManyKnots")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLink(params LinkCreateInput) *LinkExec {
	ret := client.Client.Create(
		params,
		[2]string{"LinkCreateInput!", "Link"},
		"createLink",
		[]string{"id", "source", "target"})

	return &LinkExec{ret}
}

type LinkUpdateParams struct {
	Data  LinkUpdateInput      `json:"data"`
	Where LinkWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLink(params LinkUpdateParams) *LinkExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LinkUpdateInput!", "LinkWhereUniqueInput!", "Link"},
		"updateLink",
		[]string{"id", "source", "target"})

	return &LinkExec{ret}
}

type LinkUpdateManyParams struct {
	Data  LinkUpdateManyMutationInput `json:"data"`
	Where *LinkWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLinks(params LinkUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LinkUpdateManyMutationInput!", "LinkWhereInput"},
		"updateManyLinks")
	return &BatchPayloadExec{exec}
}

type LinkUpsertParams struct {
	Where  LinkWhereUniqueInput `json:"where"`
	Create LinkCreateInput      `json:"create"`
	Update LinkUpdateInput      `json:"update"`
}

func (client *Client) UpsertLink(params LinkUpsertParams) *LinkExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LinkWhereUniqueInput!", "LinkCreateInput!", "LinkUpdateInput!", "Link"},
		"upsertLink",
		[]string{"id", "source", "target"})

	return &LinkExec{ret}
}

func (client *Client) DeleteLink(params LinkWhereUniqueInput) *LinkExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LinkWhereUniqueInput!", "Link"},
		"deleteLink",
		[]string{"id", "source", "target"})

	return &LinkExec{ret}
}

func (client *Client) DeleteManyLinks(params *LinkWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LinkWhereInput", "deleteManyLinks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLinkedApp(params LinkedAppCreateInput) *LinkedAppExec {
	ret := client.Client.Create(
		params,
		[2]string{"LinkedAppCreateInput!", "LinkedApp"},
		"createLinkedApp",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExec{ret}
}

type LinkedAppUpdateParams struct {
	Data  LinkedAppUpdateInput      `json:"data"`
	Where LinkedAppWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLinkedApp(params LinkedAppUpdateParams) *LinkedAppExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LinkedAppUpdateInput!", "LinkedAppWhereUniqueInput!", "LinkedApp"},
		"updateLinkedApp",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExec{ret}
}

type LinkedAppUpdateManyParams struct {
	Data  LinkedAppUpdateManyMutationInput `json:"data"`
	Where *LinkedAppWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLinkedApps(params LinkedAppUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LinkedAppUpdateManyMutationInput!", "LinkedAppWhereInput"},
		"updateManyLinkedApps")
	return &BatchPayloadExec{exec}
}

type LinkedAppUpsertParams struct {
	Where  LinkedAppWhereUniqueInput `json:"where"`
	Create LinkedAppCreateInput      `json:"create"`
	Update LinkedAppUpdateInput      `json:"update"`
}

func (client *Client) UpsertLinkedApp(params LinkedAppUpsertParams) *LinkedAppExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LinkedAppWhereUniqueInput!", "LinkedAppCreateInput!", "LinkedAppUpdateInput!", "LinkedApp"},
		"upsertLinkedApp",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExec{ret}
}

func (client *Client) DeleteLinkedApp(params LinkedAppWhereUniqueInput) *LinkedAppExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LinkedAppWhereUniqueInput!", "LinkedApp"},
		"deleteLinkedApp",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExec{ret}
}

func (client *Client) DeleteManyLinkedApps(params *LinkedAppWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LinkedAppWhereInput", "deleteManyLinkedApps")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateMap(params MapCreateInput) *MapExec {
	ret := client.Client.Create(
		params,
		[2]string{"MapCreateInput!", "Map"},
		"createMap",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

type MapUpdateParams struct {
	Data  MapUpdateInput      `json:"data"`
	Where MapWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateMap(params MapUpdateParams) *MapExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"MapUpdateInput!", "MapWhereUniqueInput!", "Map"},
		"updateMap",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

type MapUpdateManyParams struct {
	Data  MapUpdateManyMutationInput `json:"data"`
	Where *MapWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyMaps(params MapUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"MapUpdateManyMutationInput!", "MapWhereInput"},
		"updateManyMaps")
	return &BatchPayloadExec{exec}
}

type MapUpsertParams struct {
	Where  MapWhereUniqueInput `json:"where"`
	Create MapCreateInput      `json:"create"`
	Update MapUpdateInput      `json:"update"`
}

func (client *Client) UpsertMap(params MapUpsertParams) *MapExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"MapWhereUniqueInput!", "MapCreateInput!", "MapUpdateInput!", "Map"},
		"upsertMap",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

func (client *Client) DeleteMap(params MapWhereUniqueInput) *MapExec {
	ret := client.Client.Delete(
		params,
		[2]string{"MapWhereUniqueInput!", "Map"},
		"deleteMap",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

func (client *Client) DeleteManyMaps(params *MapWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "MapWhereInput", "deleteManyMaps")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type AppType string

const (
	AppTypeSpotify AppType = "SPOTIFY"
)

type MapOrderByInput string

const (
	MapOrderByInputIDAsc          MapOrderByInput = "id_ASC"
	MapOrderByInputIDDesc         MapOrderByInput = "id_DESC"
	MapOrderByInputTitleAsc       MapOrderByInput = "title_ASC"
	MapOrderByInputTitleDesc      MapOrderByInput = "title_DESC"
	MapOrderByInputFlagshipIdAsc  MapOrderByInput = "flagshipId_ASC"
	MapOrderByInputFlagshipIdDesc MapOrderByInput = "flagshipId_DESC"
	MapOrderByInputPublicAsc      MapOrderByInput = "public_ASC"
	MapOrderByInputPublicDesc     MapOrderByInput = "public_DESC"
	MapOrderByInputCreatedAtAsc   MapOrderByInput = "createdAt_ASC"
	MapOrderByInputCreatedAtDesc  MapOrderByInput = "createdAt_DESC"
	MapOrderByInputUpdatedAtAsc   MapOrderByInput = "updatedAt_ASC"
	MapOrderByInputUpdatedAtDesc  MapOrderByInput = "updatedAt_DESC"
)

type LinkedAppOrderByInput string

const (
	LinkedAppOrderByInputIDAsc            LinkedAppOrderByInput = "id_ASC"
	LinkedAppOrderByInputIDDesc           LinkedAppOrderByInput = "id_DESC"
	LinkedAppOrderByInputTypeAsc          LinkedAppOrderByInput = "type_ASC"
	LinkedAppOrderByInputTypeDesc         LinkedAppOrderByInput = "type_DESC"
	LinkedAppOrderByInputAccessTokenAsc   LinkedAppOrderByInput = "accessToken_ASC"
	LinkedAppOrderByInputAccessTokenDesc  LinkedAppOrderByInput = "accessToken_DESC"
	LinkedAppOrderByInputTokenExpiryAsc   LinkedAppOrderByInput = "tokenExpiry_ASC"
	LinkedAppOrderByInputTokenExpiryDesc  LinkedAppOrderByInput = "tokenExpiry_DESC"
	LinkedAppOrderByInputRefreshTokenAsc  LinkedAppOrderByInput = "refreshToken_ASC"
	LinkedAppOrderByInputRefreshTokenDesc LinkedAppOrderByInput = "refreshToken_DESC"
	LinkedAppOrderByInputUserIdAsc        LinkedAppOrderByInput = "userId_ASC"
	LinkedAppOrderByInputUserIdDesc       LinkedAppOrderByInput = "userId_DESC"
	LinkedAppOrderByInputUsernameAsc      LinkedAppOrderByInput = "username_ASC"
	LinkedAppOrderByInputUsernameDesc     LinkedAppOrderByInput = "username_DESC"
)

type KnotOrderByInput string

const (
	KnotOrderByInputIDAsc         KnotOrderByInput = "id_ASC"
	KnotOrderByInputIDDesc        KnotOrderByInput = "id_DESC"
	KnotOrderByInputTrackIdAsc    KnotOrderByInput = "trackId_ASC"
	KnotOrderByInputTrackIdDesc   KnotOrderByInput = "trackId_DESC"
	KnotOrderByInputLevelAsc      KnotOrderByInput = "level_ASC"
	KnotOrderByInputLevelDesc     KnotOrderByInput = "level_DESC"
	KnotOrderByInputVisitedAsc    KnotOrderByInput = "visited_ASC"
	KnotOrderByInputVisitedDesc   KnotOrderByInput = "visited_DESC"
	KnotOrderByInputCreatedAtAsc  KnotOrderByInput = "createdAt_ASC"
	KnotOrderByInputCreatedAtDesc KnotOrderByInput = "createdAt_DESC"
	KnotOrderByInputUpdatedAtAsc  KnotOrderByInput = "updatedAt_ASC"
	KnotOrderByInputUpdatedAtDesc KnotOrderByInput = "updatedAt_DESC"
)

type LinkOrderByInput string

const (
	LinkOrderByInputIDAsc      LinkOrderByInput = "id_ASC"
	LinkOrderByInputIDDesc     LinkOrderByInput = "id_DESC"
	LinkOrderByInputSourceAsc  LinkOrderByInput = "source_ASC"
	LinkOrderByInputSourceDesc LinkOrderByInput = "source_DESC"
	LinkOrderByInputTargetAsc  LinkOrderByInput = "target_ASC"
	LinkOrderByInputTargetDesc LinkOrderByInput = "target_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc        UserOrderByInput = "id_DESC"
	UserOrderByInputUsernameAsc   UserOrderByInput = "username_ASC"
	UserOrderByInputUsernameDesc  UserOrderByInput = "username_DESC"
	UserOrderByInputCreatedAtAsc  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type KnotWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type MapWhereInput struct {
	ID                      *string         `json:"id,omitempty"`
	IDNot                   *string         `json:"id_not,omitempty"`
	IDIn                    []string        `json:"id_in,omitempty"`
	IDNotIn                 []string        `json:"id_not_in,omitempty"`
	IDLt                    *string         `json:"id_lt,omitempty"`
	IDLte                   *string         `json:"id_lte,omitempty"`
	IDGt                    *string         `json:"id_gt,omitempty"`
	IDGte                   *string         `json:"id_gte,omitempty"`
	IDContains              *string         `json:"id_contains,omitempty"`
	IDNotContains           *string         `json:"id_not_contains,omitempty"`
	IDStartsWith            *string         `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string         `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string         `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string         `json:"id_not_ends_with,omitempty"`
	Title                   *string         `json:"title,omitempty"`
	TitleNot                *string         `json:"title_not,omitempty"`
	TitleIn                 []string        `json:"title_in,omitempty"`
	TitleNotIn              []string        `json:"title_not_in,omitempty"`
	TitleLt                 *string         `json:"title_lt,omitempty"`
	TitleLte                *string         `json:"title_lte,omitempty"`
	TitleGt                 *string         `json:"title_gt,omitempty"`
	TitleGte                *string         `json:"title_gte,omitempty"`
	TitleContains           *string         `json:"title_contains,omitempty"`
	TitleNotContains        *string         `json:"title_not_contains,omitempty"`
	TitleStartsWith         *string         `json:"title_starts_with,omitempty"`
	TitleNotStartsWith      *string         `json:"title_not_starts_with,omitempty"`
	TitleEndsWith           *string         `json:"title_ends_with,omitempty"`
	TitleNotEndsWith        *string         `json:"title_not_ends_with,omitempty"`
	Author                  *UserWhereInput `json:"author,omitempty"`
	FlagshipId              *string         `json:"flagshipId,omitempty"`
	FlagshipIdNot           *string         `json:"flagshipId_not,omitempty"`
	FlagshipIdIn            []string        `json:"flagshipId_in,omitempty"`
	FlagshipIdNotIn         []string        `json:"flagshipId_not_in,omitempty"`
	FlagshipIdLt            *string         `json:"flagshipId_lt,omitempty"`
	FlagshipIdLte           *string         `json:"flagshipId_lte,omitempty"`
	FlagshipIdGt            *string         `json:"flagshipId_gt,omitempty"`
	FlagshipIdGte           *string         `json:"flagshipId_gte,omitempty"`
	FlagshipIdContains      *string         `json:"flagshipId_contains,omitempty"`
	FlagshipIdNotContains   *string         `json:"flagshipId_not_contains,omitempty"`
	FlagshipIdStartsWith    *string         `json:"flagshipId_starts_with,omitempty"`
	FlagshipIdNotStartsWith *string         `json:"flagshipId_not_starts_with,omitempty"`
	FlagshipIdEndsWith      *string         `json:"flagshipId_ends_with,omitempty"`
	FlagshipIdNotEndsWith   *string         `json:"flagshipId_not_ends_with,omitempty"`
	Public                  *bool           `json:"public,omitempty"`
	PublicNot               *bool           `json:"public_not,omitempty"`
	CreatedAt               *string         `json:"createdAt,omitempty"`
	CreatedAtNot            *string         `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string         `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string         `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string         `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string         `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string         `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string         `json:"updatedAt_gte,omitempty"`
	KnotsEvery              *KnotWhereInput `json:"knots_every,omitempty"`
	KnotsSome               *KnotWhereInput `json:"knots_some,omitempty"`
	KnotsNone               *KnotWhereInput `json:"knots_none,omitempty"`
	LinksEvery              *LinkWhereInput `json:"links_every,omitempty"`
	LinksSome               *LinkWhereInput `json:"links_some,omitempty"`
	LinksNone               *LinkWhereInput `json:"links_none,omitempty"`
	And                     []MapWhereInput `json:"AND,omitempty"`
	Or                      []MapWhereInput `json:"OR,omitempty"`
	Not                     []MapWhereInput `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                    *string              `json:"id,omitempty"`
	IDNot                 *string              `json:"id_not,omitempty"`
	IDIn                  []string             `json:"id_in,omitempty"`
	IDNotIn               []string             `json:"id_not_in,omitempty"`
	IDLt                  *string              `json:"id_lt,omitempty"`
	IDLte                 *string              `json:"id_lte,omitempty"`
	IDGt                  *string              `json:"id_gt,omitempty"`
	IDGte                 *string              `json:"id_gte,omitempty"`
	IDContains            *string              `json:"id_contains,omitempty"`
	IDNotContains         *string              `json:"id_not_contains,omitempty"`
	IDStartsWith          *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string              `json:"id_not_ends_with,omitempty"`
	Username              *string              `json:"username,omitempty"`
	UsernameNot           *string              `json:"username_not,omitempty"`
	UsernameIn            []string             `json:"username_in,omitempty"`
	UsernameNotIn         []string             `json:"username_not_in,omitempty"`
	UsernameLt            *string              `json:"username_lt,omitempty"`
	UsernameLte           *string              `json:"username_lte,omitempty"`
	UsernameGt            *string              `json:"username_gt,omitempty"`
	UsernameGte           *string              `json:"username_gte,omitempty"`
	UsernameContains      *string              `json:"username_contains,omitempty"`
	UsernameNotContains   *string              `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string              `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string              `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string              `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string              `json:"username_not_ends_with,omitempty"`
	CreatedAt             *string              `json:"createdAt,omitempty"`
	CreatedAtNot          *string              `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string              `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string              `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string              `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string              `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string              `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string              `json:"updatedAt_gte,omitempty"`
	MapsEvery             *MapWhereInput       `json:"maps_every,omitempty"`
	MapsSome              *MapWhereInput       `json:"maps_some,omitempty"`
	MapsNone              *MapWhereInput       `json:"maps_none,omitempty"`
	LinkedAppsEvery       *LinkedAppWhereInput `json:"linkedApps_every,omitempty"`
	LinkedAppsSome        *LinkedAppWhereInput `json:"linkedApps_some,omitempty"`
	LinkedAppsNone        *LinkedAppWhereInput `json:"linkedApps_none,omitempty"`
	And                   []UserWhereInput     `json:"AND,omitempty"`
	Or                    []UserWhereInput     `json:"OR,omitempty"`
	Not                   []UserWhereInput     `json:"NOT,omitempty"`
}

type LinkedAppWhereInput struct {
	ID                        *string               `json:"id,omitempty"`
	IDNot                     *string               `json:"id_not,omitempty"`
	IDIn                      []string              `json:"id_in,omitempty"`
	IDNotIn                   []string              `json:"id_not_in,omitempty"`
	IDLt                      *string               `json:"id_lt,omitempty"`
	IDLte                     *string               `json:"id_lte,omitempty"`
	IDGt                      *string               `json:"id_gt,omitempty"`
	IDGte                     *string               `json:"id_gte,omitempty"`
	IDContains                *string               `json:"id_contains,omitempty"`
	IDNotContains             *string               `json:"id_not_contains,omitempty"`
	IDStartsWith              *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string               `json:"id_not_ends_with,omitempty"`
	Type                      *AppType              `json:"type,omitempty"`
	TypeNot                   *AppType              `json:"type_not,omitempty"`
	TypeIn                    []AppType             `json:"type_in,omitempty"`
	TypeNotIn                 []AppType             `json:"type_not_in,omitempty"`
	AccessToken               *string               `json:"accessToken,omitempty"`
	AccessTokenNot            *string               `json:"accessToken_not,omitempty"`
	AccessTokenIn             []string              `json:"accessToken_in,omitempty"`
	AccessTokenNotIn          []string              `json:"accessToken_not_in,omitempty"`
	AccessTokenLt             *string               `json:"accessToken_lt,omitempty"`
	AccessTokenLte            *string               `json:"accessToken_lte,omitempty"`
	AccessTokenGt             *string               `json:"accessToken_gt,omitempty"`
	AccessTokenGte            *string               `json:"accessToken_gte,omitempty"`
	AccessTokenContains       *string               `json:"accessToken_contains,omitempty"`
	AccessTokenNotContains    *string               `json:"accessToken_not_contains,omitempty"`
	AccessTokenStartsWith     *string               `json:"accessToken_starts_with,omitempty"`
	AccessTokenNotStartsWith  *string               `json:"accessToken_not_starts_with,omitempty"`
	AccessTokenEndsWith       *string               `json:"accessToken_ends_with,omitempty"`
	AccessTokenNotEndsWith    *string               `json:"accessToken_not_ends_with,omitempty"`
	TokenExpiry               *string               `json:"tokenExpiry,omitempty"`
	TokenExpiryNot            *string               `json:"tokenExpiry_not,omitempty"`
	TokenExpiryIn             []string              `json:"tokenExpiry_in,omitempty"`
	TokenExpiryNotIn          []string              `json:"tokenExpiry_not_in,omitempty"`
	TokenExpiryLt             *string               `json:"tokenExpiry_lt,omitempty"`
	TokenExpiryLte            *string               `json:"tokenExpiry_lte,omitempty"`
	TokenExpiryGt             *string               `json:"tokenExpiry_gt,omitempty"`
	TokenExpiryGte            *string               `json:"tokenExpiry_gte,omitempty"`
	RefreshToken              *string               `json:"refreshToken,omitempty"`
	RefreshTokenNot           *string               `json:"refreshToken_not,omitempty"`
	RefreshTokenIn            []string              `json:"refreshToken_in,omitempty"`
	RefreshTokenNotIn         []string              `json:"refreshToken_not_in,omitempty"`
	RefreshTokenLt            *string               `json:"refreshToken_lt,omitempty"`
	RefreshTokenLte           *string               `json:"refreshToken_lte,omitempty"`
	RefreshTokenGt            *string               `json:"refreshToken_gt,omitempty"`
	RefreshTokenGte           *string               `json:"refreshToken_gte,omitempty"`
	RefreshTokenContains      *string               `json:"refreshToken_contains,omitempty"`
	RefreshTokenNotContains   *string               `json:"refreshToken_not_contains,omitempty"`
	RefreshTokenStartsWith    *string               `json:"refreshToken_starts_with,omitempty"`
	RefreshTokenNotStartsWith *string               `json:"refreshToken_not_starts_with,omitempty"`
	RefreshTokenEndsWith      *string               `json:"refreshToken_ends_with,omitempty"`
	RefreshTokenNotEndsWith   *string               `json:"refreshToken_not_ends_with,omitempty"`
	UserId                    *string               `json:"userId,omitempty"`
	UserIdNot                 *string               `json:"userId_not,omitempty"`
	UserIdIn                  []string              `json:"userId_in,omitempty"`
	UserIdNotIn               []string              `json:"userId_not_in,omitempty"`
	UserIdLt                  *string               `json:"userId_lt,omitempty"`
	UserIdLte                 *string               `json:"userId_lte,omitempty"`
	UserIdGt                  *string               `json:"userId_gt,omitempty"`
	UserIdGte                 *string               `json:"userId_gte,omitempty"`
	UserIdContains            *string               `json:"userId_contains,omitempty"`
	UserIdNotContains         *string               `json:"userId_not_contains,omitempty"`
	UserIdStartsWith          *string               `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith       *string               `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith            *string               `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith         *string               `json:"userId_not_ends_with,omitempty"`
	Username                  *string               `json:"username,omitempty"`
	UsernameNot               *string               `json:"username_not,omitempty"`
	UsernameIn                []string              `json:"username_in,omitempty"`
	UsernameNotIn             []string              `json:"username_not_in,omitempty"`
	UsernameLt                *string               `json:"username_lt,omitempty"`
	UsernameLte               *string               `json:"username_lte,omitempty"`
	UsernameGt                *string               `json:"username_gt,omitempty"`
	UsernameGte               *string               `json:"username_gte,omitempty"`
	UsernameContains          *string               `json:"username_contains,omitempty"`
	UsernameNotContains       *string               `json:"username_not_contains,omitempty"`
	UsernameStartsWith        *string               `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith     *string               `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith          *string               `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith       *string               `json:"username_not_ends_with,omitempty"`
	User                      *UserWhereInput       `json:"user,omitempty"`
	And                       []LinkedAppWhereInput `json:"AND,omitempty"`
	Or                        []LinkedAppWhereInput `json:"OR,omitempty"`
	Not                       []LinkedAppWhereInput `json:"NOT,omitempty"`
}

type KnotWhereInput struct {
	ID                   *string          `json:"id,omitempty"`
	IDNot                *string          `json:"id_not,omitempty"`
	IDIn                 []string         `json:"id_in,omitempty"`
	IDNotIn              []string         `json:"id_not_in,omitempty"`
	IDLt                 *string          `json:"id_lt,omitempty"`
	IDLte                *string          `json:"id_lte,omitempty"`
	IDGt                 *string          `json:"id_gt,omitempty"`
	IDGte                *string          `json:"id_gte,omitempty"`
	IDContains           *string          `json:"id_contains,omitempty"`
	IDNotContains        *string          `json:"id_not_contains,omitempty"`
	IDStartsWith         *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string          `json:"id_not_ends_with,omitempty"`
	TrackId              *string          `json:"trackId,omitempty"`
	TrackIdNot           *string          `json:"trackId_not,omitempty"`
	TrackIdIn            []string         `json:"trackId_in,omitempty"`
	TrackIdNotIn         []string         `json:"trackId_not_in,omitempty"`
	TrackIdLt            *string          `json:"trackId_lt,omitempty"`
	TrackIdLte           *string          `json:"trackId_lte,omitempty"`
	TrackIdGt            *string          `json:"trackId_gt,omitempty"`
	TrackIdGte           *string          `json:"trackId_gte,omitempty"`
	TrackIdContains      *string          `json:"trackId_contains,omitempty"`
	TrackIdNotContains   *string          `json:"trackId_not_contains,omitempty"`
	TrackIdStartsWith    *string          `json:"trackId_starts_with,omitempty"`
	TrackIdNotStartsWith *string          `json:"trackId_not_starts_with,omitempty"`
	TrackIdEndsWith      *string          `json:"trackId_ends_with,omitempty"`
	TrackIdNotEndsWith   *string          `json:"trackId_not_ends_with,omitempty"`
	Level                *int32           `json:"level,omitempty"`
	LevelNot             *int32           `json:"level_not,omitempty"`
	LevelIn              []int32          `json:"level_in,omitempty"`
	LevelNotIn           []int32          `json:"level_not_in,omitempty"`
	LevelLt              *int32           `json:"level_lt,omitempty"`
	LevelLte             *int32           `json:"level_lte,omitempty"`
	LevelGt              *int32           `json:"level_gt,omitempty"`
	LevelGte             *int32           `json:"level_gte,omitempty"`
	Visited              *bool            `json:"visited,omitempty"`
	VisitedNot           *bool            `json:"visited_not,omitempty"`
	Map                  *MapWhereInput   `json:"map,omitempty"`
	CreatedAt            *string          `json:"createdAt,omitempty"`
	CreatedAtNot         *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string          `json:"updatedAt_gte,omitempty"`
	And                  []KnotWhereInput `json:"AND,omitempty"`
	Or                   []KnotWhereInput `json:"OR,omitempty"`
	Not                  []KnotWhereInput `json:"NOT,omitempty"`
}

type LinkWhereInput struct {
	ID                  *string          `json:"id,omitempty"`
	IDNot               *string          `json:"id_not,omitempty"`
	IDIn                []string         `json:"id_in,omitempty"`
	IDNotIn             []string         `json:"id_not_in,omitempty"`
	IDLt                *string          `json:"id_lt,omitempty"`
	IDLte               *string          `json:"id_lte,omitempty"`
	IDGt                *string          `json:"id_gt,omitempty"`
	IDGte               *string          `json:"id_gte,omitempty"`
	IDContains          *string          `json:"id_contains,omitempty"`
	IDNotContains       *string          `json:"id_not_contains,omitempty"`
	IDStartsWith        *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string          `json:"id_not_ends_with,omitempty"`
	Map                 *MapWhereInput   `json:"map,omitempty"`
	Source              *string          `json:"source,omitempty"`
	SourceNot           *string          `json:"source_not,omitempty"`
	SourceIn            []string         `json:"source_in,omitempty"`
	SourceNotIn         []string         `json:"source_not_in,omitempty"`
	SourceLt            *string          `json:"source_lt,omitempty"`
	SourceLte           *string          `json:"source_lte,omitempty"`
	SourceGt            *string          `json:"source_gt,omitempty"`
	SourceGte           *string          `json:"source_gte,omitempty"`
	SourceContains      *string          `json:"source_contains,omitempty"`
	SourceNotContains   *string          `json:"source_not_contains,omitempty"`
	SourceStartsWith    *string          `json:"source_starts_with,omitempty"`
	SourceNotStartsWith *string          `json:"source_not_starts_with,omitempty"`
	SourceEndsWith      *string          `json:"source_ends_with,omitempty"`
	SourceNotEndsWith   *string          `json:"source_not_ends_with,omitempty"`
	Target              *string          `json:"target,omitempty"`
	TargetNot           *string          `json:"target_not,omitempty"`
	TargetIn            []string         `json:"target_in,omitempty"`
	TargetNotIn         []string         `json:"target_not_in,omitempty"`
	TargetLt            *string          `json:"target_lt,omitempty"`
	TargetLte           *string          `json:"target_lte,omitempty"`
	TargetGt            *string          `json:"target_gt,omitempty"`
	TargetGte           *string          `json:"target_gte,omitempty"`
	TargetContains      *string          `json:"target_contains,omitempty"`
	TargetNotContains   *string          `json:"target_not_contains,omitempty"`
	TargetStartsWith    *string          `json:"target_starts_with,omitempty"`
	TargetNotStartsWith *string          `json:"target_not_starts_with,omitempty"`
	TargetEndsWith      *string          `json:"target_ends_with,omitempty"`
	TargetNotEndsWith   *string          `json:"target_not_ends_with,omitempty"`
	And                 []LinkWhereInput `json:"AND,omitempty"`
	Or                  []LinkWhereInput `json:"OR,omitempty"`
	Not                 []LinkWhereInput `json:"NOT,omitempty"`
}

type LinkWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LinkedAppWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type MapWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type KnotCreateInput struct {
	ID      *string                       `json:"id,omitempty"`
	TrackId string                        `json:"trackId"`
	Level   int32                         `json:"level"`
	Visited *bool                         `json:"visited,omitempty"`
	Map     MapCreateOneWithoutKnotsInput `json:"map"`
}

type MapCreateOneWithoutKnotsInput struct {
	Create  *MapCreateWithoutKnotsInput `json:"create,omitempty"`
	Connect *MapWhereUniqueInput        `json:"connect,omitempty"`
}

type MapCreateWithoutKnotsInput struct {
	ID         *string                        `json:"id,omitempty"`
	Title      *string                        `json:"title,omitempty"`
	Author     UserCreateOneWithoutMapsInput  `json:"author"`
	FlagshipId *string                        `json:"flagshipId,omitempty"`
	Public     *bool                          `json:"public,omitempty"`
	Links      *LinkCreateManyWithoutMapInput `json:"links,omitempty"`
}

type UserCreateOneWithoutMapsInput struct {
	Create  *UserCreateWithoutMapsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput       `json:"connect,omitempty"`
}

type UserCreateWithoutMapsInput struct {
	ID         *string                              `json:"id,omitempty"`
	Username   *string                              `json:"username,omitempty"`
	LinkedApps *LinkedAppCreateManyWithoutUserInput `json:"linkedApps,omitempty"`
}

type LinkedAppCreateManyWithoutUserInput struct {
	Create  []LinkedAppCreateWithoutUserInput `json:"create,omitempty"`
	Connect []LinkedAppWhereUniqueInput       `json:"connect,omitempty"`
}

type LinkedAppCreateWithoutUserInput struct {
	ID           *string `json:"id,omitempty"`
	Type         AppType `json:"type"`
	AccessToken  *string `json:"accessToken,omitempty"`
	TokenExpiry  *string `json:"tokenExpiry,omitempty"`
	RefreshToken *string `json:"refreshToken,omitempty"`
	UserId       string  `json:"userId"`
	Username     *string `json:"username,omitempty"`
}

type LinkCreateManyWithoutMapInput struct {
	Create  []LinkCreateWithoutMapInput `json:"create,omitempty"`
	Connect []LinkWhereUniqueInput      `json:"connect,omitempty"`
}

type LinkCreateWithoutMapInput struct {
	ID     *string `json:"id,omitempty"`
	Source string  `json:"source"`
	Target string  `json:"target"`
}

type KnotUpdateInput struct {
	TrackId *string                                `json:"trackId,omitempty"`
	Level   *int32                                 `json:"level,omitempty"`
	Visited *bool                                  `json:"visited,omitempty"`
	Map     *MapUpdateOneRequiredWithoutKnotsInput `json:"map,omitempty"`
}

type MapUpdateOneRequiredWithoutKnotsInput struct {
	Create  *MapCreateWithoutKnotsInput     `json:"create,omitempty"`
	Update  *MapUpdateWithoutKnotsDataInput `json:"update,omitempty"`
	Upsert  *MapUpsertWithoutKnotsInput     `json:"upsert,omitempty"`
	Connect *MapWhereUniqueInput            `json:"connect,omitempty"`
}

type MapUpdateWithoutKnotsDataInput struct {
	Title      *string                                `json:"title,omitempty"`
	Author     *UserUpdateOneRequiredWithoutMapsInput `json:"author,omitempty"`
	FlagshipId *string                                `json:"flagshipId,omitempty"`
	Public     *bool                                  `json:"public,omitempty"`
	Links      *LinkUpdateManyWithoutMapInput         `json:"links,omitempty"`
}

type UserUpdateOneRequiredWithoutMapsInput struct {
	Create  *UserCreateWithoutMapsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutMapsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutMapsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserUpdateWithoutMapsDataInput struct {
	Username   *string                              `json:"username,omitempty"`
	LinkedApps *LinkedAppUpdateManyWithoutUserInput `json:"linkedApps,omitempty"`
}

type LinkedAppUpdateManyWithoutUserInput struct {
	Create     []LinkedAppCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []LinkedAppWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []LinkedAppWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []LinkedAppWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []LinkedAppWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []LinkedAppUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []LinkedAppUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []LinkedAppScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []LinkedAppUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type LinkedAppUpdateWithWhereUniqueWithoutUserInput struct {
	Where LinkedAppWhereUniqueInput           `json:"where"`
	Data  LinkedAppUpdateWithoutUserDataInput `json:"data"`
}

type LinkedAppUpdateWithoutUserDataInput struct {
	Type         *AppType `json:"type,omitempty"`
	AccessToken  *string  `json:"accessToken,omitempty"`
	TokenExpiry  *string  `json:"tokenExpiry,omitempty"`
	RefreshToken *string  `json:"refreshToken,omitempty"`
	UserId       *string  `json:"userId,omitempty"`
	Username     *string  `json:"username,omitempty"`
}

type LinkedAppUpsertWithWhereUniqueWithoutUserInput struct {
	Where  LinkedAppWhereUniqueInput           `json:"where"`
	Update LinkedAppUpdateWithoutUserDataInput `json:"update"`
	Create LinkedAppCreateWithoutUserInput     `json:"create"`
}

type LinkedAppScalarWhereInput struct {
	ID                        *string                     `json:"id,omitempty"`
	IDNot                     *string                     `json:"id_not,omitempty"`
	IDIn                      []string                    `json:"id_in,omitempty"`
	IDNotIn                   []string                    `json:"id_not_in,omitempty"`
	IDLt                      *string                     `json:"id_lt,omitempty"`
	IDLte                     *string                     `json:"id_lte,omitempty"`
	IDGt                      *string                     `json:"id_gt,omitempty"`
	IDGte                     *string                     `json:"id_gte,omitempty"`
	IDContains                *string                     `json:"id_contains,omitempty"`
	IDNotContains             *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                     `json:"id_not_ends_with,omitempty"`
	Type                      *AppType                    `json:"type,omitempty"`
	TypeNot                   *AppType                    `json:"type_not,omitempty"`
	TypeIn                    []AppType                   `json:"type_in,omitempty"`
	TypeNotIn                 []AppType                   `json:"type_not_in,omitempty"`
	AccessToken               *string                     `json:"accessToken,omitempty"`
	AccessTokenNot            *string                     `json:"accessToken_not,omitempty"`
	AccessTokenIn             []string                    `json:"accessToken_in,omitempty"`
	AccessTokenNotIn          []string                    `json:"accessToken_not_in,omitempty"`
	AccessTokenLt             *string                     `json:"accessToken_lt,omitempty"`
	AccessTokenLte            *string                     `json:"accessToken_lte,omitempty"`
	AccessTokenGt             *string                     `json:"accessToken_gt,omitempty"`
	AccessTokenGte            *string                     `json:"accessToken_gte,omitempty"`
	AccessTokenContains       *string                     `json:"accessToken_contains,omitempty"`
	AccessTokenNotContains    *string                     `json:"accessToken_not_contains,omitempty"`
	AccessTokenStartsWith     *string                     `json:"accessToken_starts_with,omitempty"`
	AccessTokenNotStartsWith  *string                     `json:"accessToken_not_starts_with,omitempty"`
	AccessTokenEndsWith       *string                     `json:"accessToken_ends_with,omitempty"`
	AccessTokenNotEndsWith    *string                     `json:"accessToken_not_ends_with,omitempty"`
	TokenExpiry               *string                     `json:"tokenExpiry,omitempty"`
	TokenExpiryNot            *string                     `json:"tokenExpiry_not,omitempty"`
	TokenExpiryIn             []string                    `json:"tokenExpiry_in,omitempty"`
	TokenExpiryNotIn          []string                    `json:"tokenExpiry_not_in,omitempty"`
	TokenExpiryLt             *string                     `json:"tokenExpiry_lt,omitempty"`
	TokenExpiryLte            *string                     `json:"tokenExpiry_lte,omitempty"`
	TokenExpiryGt             *string                     `json:"tokenExpiry_gt,omitempty"`
	TokenExpiryGte            *string                     `json:"tokenExpiry_gte,omitempty"`
	RefreshToken              *string                     `json:"refreshToken,omitempty"`
	RefreshTokenNot           *string                     `json:"refreshToken_not,omitempty"`
	RefreshTokenIn            []string                    `json:"refreshToken_in,omitempty"`
	RefreshTokenNotIn         []string                    `json:"refreshToken_not_in,omitempty"`
	RefreshTokenLt            *string                     `json:"refreshToken_lt,omitempty"`
	RefreshTokenLte           *string                     `json:"refreshToken_lte,omitempty"`
	RefreshTokenGt            *string                     `json:"refreshToken_gt,omitempty"`
	RefreshTokenGte           *string                     `json:"refreshToken_gte,omitempty"`
	RefreshTokenContains      *string                     `json:"refreshToken_contains,omitempty"`
	RefreshTokenNotContains   *string                     `json:"refreshToken_not_contains,omitempty"`
	RefreshTokenStartsWith    *string                     `json:"refreshToken_starts_with,omitempty"`
	RefreshTokenNotStartsWith *string                     `json:"refreshToken_not_starts_with,omitempty"`
	RefreshTokenEndsWith      *string                     `json:"refreshToken_ends_with,omitempty"`
	RefreshTokenNotEndsWith   *string                     `json:"refreshToken_not_ends_with,omitempty"`
	UserId                    *string                     `json:"userId,omitempty"`
	UserIdNot                 *string                     `json:"userId_not,omitempty"`
	UserIdIn                  []string                    `json:"userId_in,omitempty"`
	UserIdNotIn               []string                    `json:"userId_not_in,omitempty"`
	UserIdLt                  *string                     `json:"userId_lt,omitempty"`
	UserIdLte                 *string                     `json:"userId_lte,omitempty"`
	UserIdGt                  *string                     `json:"userId_gt,omitempty"`
	UserIdGte                 *string                     `json:"userId_gte,omitempty"`
	UserIdContains            *string                     `json:"userId_contains,omitempty"`
	UserIdNotContains         *string                     `json:"userId_not_contains,omitempty"`
	UserIdStartsWith          *string                     `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith       *string                     `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith            *string                     `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith         *string                     `json:"userId_not_ends_with,omitempty"`
	Username                  *string                     `json:"username,omitempty"`
	UsernameNot               *string                     `json:"username_not,omitempty"`
	UsernameIn                []string                    `json:"username_in,omitempty"`
	UsernameNotIn             []string                    `json:"username_not_in,omitempty"`
	UsernameLt                *string                     `json:"username_lt,omitempty"`
	UsernameLte               *string                     `json:"username_lte,omitempty"`
	UsernameGt                *string                     `json:"username_gt,omitempty"`
	UsernameGte               *string                     `json:"username_gte,omitempty"`
	UsernameContains          *string                     `json:"username_contains,omitempty"`
	UsernameNotContains       *string                     `json:"username_not_contains,omitempty"`
	UsernameStartsWith        *string                     `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith     *string                     `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith          *string                     `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith       *string                     `json:"username_not_ends_with,omitempty"`
	And                       []LinkedAppScalarWhereInput `json:"AND,omitempty"`
	Or                        []LinkedAppScalarWhereInput `json:"OR,omitempty"`
	Not                       []LinkedAppScalarWhereInput `json:"NOT,omitempty"`
}

type LinkedAppUpdateManyWithWhereNestedInput struct {
	Where LinkedAppScalarWhereInput    `json:"where"`
	Data  LinkedAppUpdateManyDataInput `json:"data"`
}

type LinkedAppUpdateManyDataInput struct {
	Type         *AppType `json:"type,omitempty"`
	AccessToken  *string  `json:"accessToken,omitempty"`
	TokenExpiry  *string  `json:"tokenExpiry,omitempty"`
	RefreshToken *string  `json:"refreshToken,omitempty"`
	UserId       *string  `json:"userId,omitempty"`
	Username     *string  `json:"username,omitempty"`
}

type UserUpsertWithoutMapsInput struct {
	Update UserUpdateWithoutMapsDataInput `json:"update"`
	Create UserCreateWithoutMapsInput     `json:"create"`
}

type LinkUpdateManyWithoutMapInput struct {
	Create     []LinkCreateWithoutMapInput                `json:"create,omitempty"`
	Delete     []LinkWhereUniqueInput                     `json:"delete,omitempty"`
	Connect    []LinkWhereUniqueInput                     `json:"connect,omitempty"`
	Set        []LinkWhereUniqueInput                     `json:"set,omitempty"`
	Disconnect []LinkWhereUniqueInput                     `json:"disconnect,omitempty"`
	Update     []LinkUpdateWithWhereUniqueWithoutMapInput `json:"update,omitempty"`
	Upsert     []LinkUpsertWithWhereUniqueWithoutMapInput `json:"upsert,omitempty"`
	DeleteMany []LinkScalarWhereInput                     `json:"deleteMany,omitempty"`
	UpdateMany []LinkUpdateManyWithWhereNestedInput       `json:"updateMany,omitempty"`
}

type LinkUpdateWithWhereUniqueWithoutMapInput struct {
	Where LinkWhereUniqueInput          `json:"where"`
	Data  LinkUpdateWithoutMapDataInput `json:"data"`
}

type LinkUpdateWithoutMapDataInput struct {
	Source *string `json:"source,omitempty"`
	Target *string `json:"target,omitempty"`
}

type LinkUpsertWithWhereUniqueWithoutMapInput struct {
	Where  LinkWhereUniqueInput          `json:"where"`
	Update LinkUpdateWithoutMapDataInput `json:"update"`
	Create LinkCreateWithoutMapInput     `json:"create"`
}

type LinkScalarWhereInput struct {
	ID                  *string                `json:"id,omitempty"`
	IDNot               *string                `json:"id_not,omitempty"`
	IDIn                []string               `json:"id_in,omitempty"`
	IDNotIn             []string               `json:"id_not_in,omitempty"`
	IDLt                *string                `json:"id_lt,omitempty"`
	IDLte               *string                `json:"id_lte,omitempty"`
	IDGt                *string                `json:"id_gt,omitempty"`
	IDGte               *string                `json:"id_gte,omitempty"`
	IDContains          *string                `json:"id_contains,omitempty"`
	IDNotContains       *string                `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                `json:"id_not_ends_with,omitempty"`
	Source              *string                `json:"source,omitempty"`
	SourceNot           *string                `json:"source_not,omitempty"`
	SourceIn            []string               `json:"source_in,omitempty"`
	SourceNotIn         []string               `json:"source_not_in,omitempty"`
	SourceLt            *string                `json:"source_lt,omitempty"`
	SourceLte           *string                `json:"source_lte,omitempty"`
	SourceGt            *string                `json:"source_gt,omitempty"`
	SourceGte           *string                `json:"source_gte,omitempty"`
	SourceContains      *string                `json:"source_contains,omitempty"`
	SourceNotContains   *string                `json:"source_not_contains,omitempty"`
	SourceStartsWith    *string                `json:"source_starts_with,omitempty"`
	SourceNotStartsWith *string                `json:"source_not_starts_with,omitempty"`
	SourceEndsWith      *string                `json:"source_ends_with,omitempty"`
	SourceNotEndsWith   *string                `json:"source_not_ends_with,omitempty"`
	Target              *string                `json:"target,omitempty"`
	TargetNot           *string                `json:"target_not,omitempty"`
	TargetIn            []string               `json:"target_in,omitempty"`
	TargetNotIn         []string               `json:"target_not_in,omitempty"`
	TargetLt            *string                `json:"target_lt,omitempty"`
	TargetLte           *string                `json:"target_lte,omitempty"`
	TargetGt            *string                `json:"target_gt,omitempty"`
	TargetGte           *string                `json:"target_gte,omitempty"`
	TargetContains      *string                `json:"target_contains,omitempty"`
	TargetNotContains   *string                `json:"target_not_contains,omitempty"`
	TargetStartsWith    *string                `json:"target_starts_with,omitempty"`
	TargetNotStartsWith *string                `json:"target_not_starts_with,omitempty"`
	TargetEndsWith      *string                `json:"target_ends_with,omitempty"`
	TargetNotEndsWith   *string                `json:"target_not_ends_with,omitempty"`
	And                 []LinkScalarWhereInput `json:"AND,omitempty"`
	Or                  []LinkScalarWhereInput `json:"OR,omitempty"`
	Not                 []LinkScalarWhereInput `json:"NOT,omitempty"`
}

type LinkUpdateManyWithWhereNestedInput struct {
	Where LinkScalarWhereInput    `json:"where"`
	Data  LinkUpdateManyDataInput `json:"data"`
}

type LinkUpdateManyDataInput struct {
	Source *string `json:"source,omitempty"`
	Target *string `json:"target,omitempty"`
}

type MapUpsertWithoutKnotsInput struct {
	Update MapUpdateWithoutKnotsDataInput `json:"update"`
	Create MapCreateWithoutKnotsInput     `json:"create"`
}

type KnotUpdateManyMutationInput struct {
	TrackId *string `json:"trackId,omitempty"`
	Level   *int32  `json:"level,omitempty"`
	Visited *bool   `json:"visited,omitempty"`
}

type LinkCreateInput struct {
	ID     *string                       `json:"id,omitempty"`
	Map    MapCreateOneWithoutLinksInput `json:"map"`
	Source string                        `json:"source"`
	Target string                        `json:"target"`
}

type MapCreateOneWithoutLinksInput struct {
	Create  *MapCreateWithoutLinksInput `json:"create,omitempty"`
	Connect *MapWhereUniqueInput        `json:"connect,omitempty"`
}

type MapCreateWithoutLinksInput struct {
	ID         *string                        `json:"id,omitempty"`
	Title      *string                        `json:"title,omitempty"`
	Author     UserCreateOneWithoutMapsInput  `json:"author"`
	FlagshipId *string                        `json:"flagshipId,omitempty"`
	Public     *bool                          `json:"public,omitempty"`
	Knots      *KnotCreateManyWithoutMapInput `json:"knots,omitempty"`
}

type KnotCreateManyWithoutMapInput struct {
	Create  []KnotCreateWithoutMapInput `json:"create,omitempty"`
	Connect []KnotWhereUniqueInput      `json:"connect,omitempty"`
}

type KnotCreateWithoutMapInput struct {
	ID      *string `json:"id,omitempty"`
	TrackId string  `json:"trackId"`
	Level   int32   `json:"level"`
	Visited *bool   `json:"visited,omitempty"`
}

type LinkUpdateInput struct {
	Map    *MapUpdateOneRequiredWithoutLinksInput `json:"map,omitempty"`
	Source *string                                `json:"source,omitempty"`
	Target *string                                `json:"target,omitempty"`
}

type MapUpdateOneRequiredWithoutLinksInput struct {
	Create  *MapCreateWithoutLinksInput     `json:"create,omitempty"`
	Update  *MapUpdateWithoutLinksDataInput `json:"update,omitempty"`
	Upsert  *MapUpsertWithoutLinksInput     `json:"upsert,omitempty"`
	Connect *MapWhereUniqueInput            `json:"connect,omitempty"`
}

type MapUpdateWithoutLinksDataInput struct {
	Title      *string                                `json:"title,omitempty"`
	Author     *UserUpdateOneRequiredWithoutMapsInput `json:"author,omitempty"`
	FlagshipId *string                                `json:"flagshipId,omitempty"`
	Public     *bool                                  `json:"public,omitempty"`
	Knots      *KnotUpdateManyWithoutMapInput         `json:"knots,omitempty"`
}

type KnotUpdateManyWithoutMapInput struct {
	Create     []KnotCreateWithoutMapInput                `json:"create,omitempty"`
	Delete     []KnotWhereUniqueInput                     `json:"delete,omitempty"`
	Connect    []KnotWhereUniqueInput                     `json:"connect,omitempty"`
	Set        []KnotWhereUniqueInput                     `json:"set,omitempty"`
	Disconnect []KnotWhereUniqueInput                     `json:"disconnect,omitempty"`
	Update     []KnotUpdateWithWhereUniqueWithoutMapInput `json:"update,omitempty"`
	Upsert     []KnotUpsertWithWhereUniqueWithoutMapInput `json:"upsert,omitempty"`
	DeleteMany []KnotScalarWhereInput                     `json:"deleteMany,omitempty"`
	UpdateMany []KnotUpdateManyWithWhereNestedInput       `json:"updateMany,omitempty"`
}

type KnotUpdateWithWhereUniqueWithoutMapInput struct {
	Where KnotWhereUniqueInput          `json:"where"`
	Data  KnotUpdateWithoutMapDataInput `json:"data"`
}

type KnotUpdateWithoutMapDataInput struct {
	TrackId *string `json:"trackId,omitempty"`
	Level   *int32  `json:"level,omitempty"`
	Visited *bool   `json:"visited,omitempty"`
}

type KnotUpsertWithWhereUniqueWithoutMapInput struct {
	Where  KnotWhereUniqueInput          `json:"where"`
	Update KnotUpdateWithoutMapDataInput `json:"update"`
	Create KnotCreateWithoutMapInput     `json:"create"`
}

type KnotScalarWhereInput struct {
	ID                   *string                `json:"id,omitempty"`
	IDNot                *string                `json:"id_not,omitempty"`
	IDIn                 []string               `json:"id_in,omitempty"`
	IDNotIn              []string               `json:"id_not_in,omitempty"`
	IDLt                 *string                `json:"id_lt,omitempty"`
	IDLte                *string                `json:"id_lte,omitempty"`
	IDGt                 *string                `json:"id_gt,omitempty"`
	IDGte                *string                `json:"id_gte,omitempty"`
	IDContains           *string                `json:"id_contains,omitempty"`
	IDNotContains        *string                `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                `json:"id_not_ends_with,omitempty"`
	TrackId              *string                `json:"trackId,omitempty"`
	TrackIdNot           *string                `json:"trackId_not,omitempty"`
	TrackIdIn            []string               `json:"trackId_in,omitempty"`
	TrackIdNotIn         []string               `json:"trackId_not_in,omitempty"`
	TrackIdLt            *string                `json:"trackId_lt,omitempty"`
	TrackIdLte           *string                `json:"trackId_lte,omitempty"`
	TrackIdGt            *string                `json:"trackId_gt,omitempty"`
	TrackIdGte           *string                `json:"trackId_gte,omitempty"`
	TrackIdContains      *string                `json:"trackId_contains,omitempty"`
	TrackIdNotContains   *string                `json:"trackId_not_contains,omitempty"`
	TrackIdStartsWith    *string                `json:"trackId_starts_with,omitempty"`
	TrackIdNotStartsWith *string                `json:"trackId_not_starts_with,omitempty"`
	TrackIdEndsWith      *string                `json:"trackId_ends_with,omitempty"`
	TrackIdNotEndsWith   *string                `json:"trackId_not_ends_with,omitempty"`
	Level                *int32                 `json:"level,omitempty"`
	LevelNot             *int32                 `json:"level_not,omitempty"`
	LevelIn              []int32                `json:"level_in,omitempty"`
	LevelNotIn           []int32                `json:"level_not_in,omitempty"`
	LevelLt              *int32                 `json:"level_lt,omitempty"`
	LevelLte             *int32                 `json:"level_lte,omitempty"`
	LevelGt              *int32                 `json:"level_gt,omitempty"`
	LevelGte             *int32                 `json:"level_gte,omitempty"`
	Visited              *bool                  `json:"visited,omitempty"`
	VisitedNot           *bool                  `json:"visited_not,omitempty"`
	CreatedAt            *string                `json:"createdAt,omitempty"`
	CreatedAtNot         *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                `json:"updatedAt_gte,omitempty"`
	And                  []KnotScalarWhereInput `json:"AND,omitempty"`
	Or                   []KnotScalarWhereInput `json:"OR,omitempty"`
	Not                  []KnotScalarWhereInput `json:"NOT,omitempty"`
}

type KnotUpdateManyWithWhereNestedInput struct {
	Where KnotScalarWhereInput    `json:"where"`
	Data  KnotUpdateManyDataInput `json:"data"`
}

type KnotUpdateManyDataInput struct {
	TrackId *string `json:"trackId,omitempty"`
	Level   *int32  `json:"level,omitempty"`
	Visited *bool   `json:"visited,omitempty"`
}

type MapUpsertWithoutLinksInput struct {
	Update MapUpdateWithoutLinksDataInput `json:"update"`
	Create MapCreateWithoutLinksInput     `json:"create"`
}

type LinkUpdateManyMutationInput struct {
	Source *string `json:"source,omitempty"`
	Target *string `json:"target,omitempty"`
}

type LinkedAppCreateInput struct {
	ID           *string                             `json:"id,omitempty"`
	Type         AppType                             `json:"type"`
	AccessToken  *string                             `json:"accessToken,omitempty"`
	TokenExpiry  *string                             `json:"tokenExpiry,omitempty"`
	RefreshToken *string                             `json:"refreshToken,omitempty"`
	UserId       string                              `json:"userId"`
	Username     *string                             `json:"username,omitempty"`
	User         UserCreateOneWithoutLinkedAppsInput `json:"user"`
}

type UserCreateOneWithoutLinkedAppsInput struct {
	Create  *UserCreateWithoutLinkedAppsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput             `json:"connect,omitempty"`
}

type UserCreateWithoutLinkedAppsInput struct {
	ID       *string                          `json:"id,omitempty"`
	Username *string                          `json:"username,omitempty"`
	Maps     *MapCreateManyWithoutAuthorInput `json:"maps,omitempty"`
}

type MapCreateManyWithoutAuthorInput struct {
	Create  []MapCreateWithoutAuthorInput `json:"create,omitempty"`
	Connect []MapWhereUniqueInput         `json:"connect,omitempty"`
}

type MapCreateWithoutAuthorInput struct {
	ID         *string                        `json:"id,omitempty"`
	Title      *string                        `json:"title,omitempty"`
	FlagshipId *string                        `json:"flagshipId,omitempty"`
	Public     *bool                          `json:"public,omitempty"`
	Knots      *KnotCreateManyWithoutMapInput `json:"knots,omitempty"`
	Links      *LinkCreateManyWithoutMapInput `json:"links,omitempty"`
}

type LinkedAppUpdateInput struct {
	Type         *AppType                                     `json:"type,omitempty"`
	AccessToken  *string                                      `json:"accessToken,omitempty"`
	TokenExpiry  *string                                      `json:"tokenExpiry,omitempty"`
	RefreshToken *string                                      `json:"refreshToken,omitempty"`
	UserId       *string                                      `json:"userId,omitempty"`
	Username     *string                                      `json:"username,omitempty"`
	User         *UserUpdateOneRequiredWithoutLinkedAppsInput `json:"user,omitempty"`
}

type UserUpdateOneRequiredWithoutLinkedAppsInput struct {
	Create  *UserCreateWithoutLinkedAppsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutLinkedAppsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutLinkedAppsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                 `json:"connect,omitempty"`
}

type UserUpdateWithoutLinkedAppsDataInput struct {
	Username *string                          `json:"username,omitempty"`
	Maps     *MapUpdateManyWithoutAuthorInput `json:"maps,omitempty"`
}

type MapUpdateManyWithoutAuthorInput struct {
	Create     []MapCreateWithoutAuthorInput                `json:"create,omitempty"`
	Delete     []MapWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []MapWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []MapWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []MapWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []MapUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`
	Upsert     []MapUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`
	DeleteMany []MapScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []MapUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type MapUpdateWithWhereUniqueWithoutAuthorInput struct {
	Where MapWhereUniqueInput             `json:"where"`
	Data  MapUpdateWithoutAuthorDataInput `json:"data"`
}

type MapUpdateWithoutAuthorDataInput struct {
	Title      *string                        `json:"title,omitempty"`
	FlagshipId *string                        `json:"flagshipId,omitempty"`
	Public     *bool                          `json:"public,omitempty"`
	Knots      *KnotUpdateManyWithoutMapInput `json:"knots,omitempty"`
	Links      *LinkUpdateManyWithoutMapInput `json:"links,omitempty"`
}

type MapUpsertWithWhereUniqueWithoutAuthorInput struct {
	Where  MapWhereUniqueInput             `json:"where"`
	Update MapUpdateWithoutAuthorDataInput `json:"update"`
	Create MapCreateWithoutAuthorInput     `json:"create"`
}

type MapScalarWhereInput struct {
	ID                      *string               `json:"id,omitempty"`
	IDNot                   *string               `json:"id_not,omitempty"`
	IDIn                    []string              `json:"id_in,omitempty"`
	IDNotIn                 []string              `json:"id_not_in,omitempty"`
	IDLt                    *string               `json:"id_lt,omitempty"`
	IDLte                   *string               `json:"id_lte,omitempty"`
	IDGt                    *string               `json:"id_gt,omitempty"`
	IDGte                   *string               `json:"id_gte,omitempty"`
	IDContains              *string               `json:"id_contains,omitempty"`
	IDNotContains           *string               `json:"id_not_contains,omitempty"`
	IDStartsWith            *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string               `json:"id_not_ends_with,omitempty"`
	Title                   *string               `json:"title,omitempty"`
	TitleNot                *string               `json:"title_not,omitempty"`
	TitleIn                 []string              `json:"title_in,omitempty"`
	TitleNotIn              []string              `json:"title_not_in,omitempty"`
	TitleLt                 *string               `json:"title_lt,omitempty"`
	TitleLte                *string               `json:"title_lte,omitempty"`
	TitleGt                 *string               `json:"title_gt,omitempty"`
	TitleGte                *string               `json:"title_gte,omitempty"`
	TitleContains           *string               `json:"title_contains,omitempty"`
	TitleNotContains        *string               `json:"title_not_contains,omitempty"`
	TitleStartsWith         *string               `json:"title_starts_with,omitempty"`
	TitleNotStartsWith      *string               `json:"title_not_starts_with,omitempty"`
	TitleEndsWith           *string               `json:"title_ends_with,omitempty"`
	TitleNotEndsWith        *string               `json:"title_not_ends_with,omitempty"`
	FlagshipId              *string               `json:"flagshipId,omitempty"`
	FlagshipIdNot           *string               `json:"flagshipId_not,omitempty"`
	FlagshipIdIn            []string              `json:"flagshipId_in,omitempty"`
	FlagshipIdNotIn         []string              `json:"flagshipId_not_in,omitempty"`
	FlagshipIdLt            *string               `json:"flagshipId_lt,omitempty"`
	FlagshipIdLte           *string               `json:"flagshipId_lte,omitempty"`
	FlagshipIdGt            *string               `json:"flagshipId_gt,omitempty"`
	FlagshipIdGte           *string               `json:"flagshipId_gte,omitempty"`
	FlagshipIdContains      *string               `json:"flagshipId_contains,omitempty"`
	FlagshipIdNotContains   *string               `json:"flagshipId_not_contains,omitempty"`
	FlagshipIdStartsWith    *string               `json:"flagshipId_starts_with,omitempty"`
	FlagshipIdNotStartsWith *string               `json:"flagshipId_not_starts_with,omitempty"`
	FlagshipIdEndsWith      *string               `json:"flagshipId_ends_with,omitempty"`
	FlagshipIdNotEndsWith   *string               `json:"flagshipId_not_ends_with,omitempty"`
	Public                  *bool                 `json:"public,omitempty"`
	PublicNot               *bool                 `json:"public_not,omitempty"`
	CreatedAt               *string               `json:"createdAt,omitempty"`
	CreatedAtNot            *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string               `json:"updatedAt_gte,omitempty"`
	And                     []MapScalarWhereInput `json:"AND,omitempty"`
	Or                      []MapScalarWhereInput `json:"OR,omitempty"`
	Not                     []MapScalarWhereInput `json:"NOT,omitempty"`
}

type MapUpdateManyWithWhereNestedInput struct {
	Where MapScalarWhereInput    `json:"where"`
	Data  MapUpdateManyDataInput `json:"data"`
}

type MapUpdateManyDataInput struct {
	Title      *string `json:"title,omitempty"`
	FlagshipId *string `json:"flagshipId,omitempty"`
	Public     *bool   `json:"public,omitempty"`
}

type UserUpsertWithoutLinkedAppsInput struct {
	Update UserUpdateWithoutLinkedAppsDataInput `json:"update"`
	Create UserCreateWithoutLinkedAppsInput     `json:"create"`
}

type LinkedAppUpdateManyMutationInput struct {
	Type         *AppType `json:"type,omitempty"`
	AccessToken  *string  `json:"accessToken,omitempty"`
	TokenExpiry  *string  `json:"tokenExpiry,omitempty"`
	RefreshToken *string  `json:"refreshToken,omitempty"`
	UserId       *string  `json:"userId,omitempty"`
	Username     *string  `json:"username,omitempty"`
}

type MapCreateInput struct {
	ID         *string                        `json:"id,omitempty"`
	Title      *string                        `json:"title,omitempty"`
	Author     UserCreateOneWithoutMapsInput  `json:"author"`
	FlagshipId *string                        `json:"flagshipId,omitempty"`
	Public     *bool                          `json:"public,omitempty"`
	Knots      *KnotCreateManyWithoutMapInput `json:"knots,omitempty"`
	Links      *LinkCreateManyWithoutMapInput `json:"links,omitempty"`
}

type MapUpdateInput struct {
	Title      *string                                `json:"title,omitempty"`
	Author     *UserUpdateOneRequiredWithoutMapsInput `json:"author,omitempty"`
	FlagshipId *string                                `json:"flagshipId,omitempty"`
	Public     *bool                                  `json:"public,omitempty"`
	Knots      *KnotUpdateManyWithoutMapInput         `json:"knots,omitempty"`
	Links      *LinkUpdateManyWithoutMapInput         `json:"links,omitempty"`
}

type MapUpdateManyMutationInput struct {
	Title      *string `json:"title,omitempty"`
	FlagshipId *string `json:"flagshipId,omitempty"`
	Public     *bool   `json:"public,omitempty"`
}

type UserCreateInput struct {
	ID         *string                              `json:"id,omitempty"`
	Username   *string                              `json:"username,omitempty"`
	Maps       *MapCreateManyWithoutAuthorInput     `json:"maps,omitempty"`
	LinkedApps *LinkedAppCreateManyWithoutUserInput `json:"linkedApps,omitempty"`
}

type UserUpdateInput struct {
	Username   *string                              `json:"username,omitempty"`
	Maps       *MapUpdateManyWithoutAuthorInput     `json:"maps,omitempty"`
	LinkedApps *LinkedAppUpdateManyWithoutUserInput `json:"linkedApps,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Username *string `json:"username,omitempty"`
}

type KnotSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *KnotWhereInput              `json:"node,omitempty"`
	And                        []KnotSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []KnotSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []KnotSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LinkSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *LinkWhereInput              `json:"node,omitempty"`
	And                        []LinkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LinkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LinkSubscriptionWhereInput `json:"NOT,omitempty"`
}

type LinkedAppSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *LinkedAppWhereInput              `json:"node,omitempty"`
	And                        []LinkedAppSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LinkedAppSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LinkedAppSubscriptionWhereInput `json:"NOT,omitempty"`
}

type MapSubscriptionWhereInput struct {
	MutationIn                 []MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *MapWhereInput              `json:"node,omitempty"`
	And                        []MapSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []MapSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []MapSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type KnotExec struct {
	exec *prisma.Exec
}

func (instance *KnotExec) Map() *MapExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Map"},
		"map",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

func (instance KnotExec) Exec(ctx context.Context) (*Knot, error) {
	var v Knot
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KnotExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KnotExecArray struct {
	exec *prisma.Exec
}

func (instance KnotExecArray) Exec(ctx context.Context) ([]Knot, error) {
	var v []Knot
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var KnotFields = []string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"}

type Knot struct {
	ID        string `json:"id"`
	TrackId   string `json:"trackId"`
	Level     int32  `json:"level"`
	Visited   bool   `json:"visited"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type MapExec struct {
	exec *prisma.Exec
}

func (instance *MapExec) Author() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"author",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type KnotsParamsExec struct {
	Where   *KnotWhereInput
	OrderBy *KnotOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *MapExec) Knots(params *KnotsParamsExec) *KnotExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"KnotWhereInput", "KnotOrderByInput", "Knot"},
		"knots",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExecArray{ret}
}

type LinksParamsExec struct {
	Where   *LinkWhereInput
	OrderBy *LinkOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *MapExec) Links(params *LinksParamsExec) *LinkExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "Link"},
		"links",
		[]string{"id", "source", "target"})

	return &LinkExecArray{ret}
}

func (instance MapExec) Exec(ctx context.Context) (*Map, error) {
	var v Map
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MapExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MapExecArray struct {
	exec *prisma.Exec
}

func (instance MapExecArray) Exec(ctx context.Context) ([]Map, error) {
	var v []Map
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MapFields = []string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"}

type Map struct {
	ID         string  `json:"id"`
	Title      string  `json:"title"`
	FlagshipId *string `json:"flagshipId,omitempty"`
	Public     bool    `json:"public"`
	CreatedAt  string  `json:"createdAt"`
	UpdatedAt  string  `json:"updatedAt"`
}

type UserExec struct {
	exec *prisma.Exec
}

type MapsParamsExec struct {
	Where   *MapWhereInput
	OrderBy *MapOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Maps(params *MapsParamsExec) *MapExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"MapWhereInput", "MapOrderByInput", "Map"},
		"maps",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExecArray{ret}
}

type LinkedAppsParamsExec struct {
	Where   *LinkedAppWhereInput
	OrderBy *LinkedAppOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) LinkedApps(params *LinkedAppsParamsExec) *LinkedAppExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"LinkedAppWhereInput", "LinkedAppOrderByInput", "LinkedApp"},
		"linkedApps",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExecArray{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "username", "createdAt", "updatedAt"}

type LinkedAppExec struct {
	exec *prisma.Exec
}

func (instance *LinkedAppExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance LinkedAppExec) Exec(ctx context.Context) (*LinkedApp, error) {
	var v LinkedApp
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkedAppExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkedAppExecArray struct {
	exec *prisma.Exec
}

func (instance LinkedAppExecArray) Exec(ctx context.Context) ([]LinkedApp, error) {
	var v []LinkedApp
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkedAppFields = []string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"}

type LinkedApp struct {
	ID           string  `json:"id"`
	Type         AppType `json:"type"`
	AccessToken  *string `json:"accessToken,omitempty"`
	TokenExpiry  *string `json:"tokenExpiry,omitempty"`
	RefreshToken *string `json:"refreshToken,omitempty"`
	UserId       string  `json:"userId"`
	Username     *string `json:"username,omitempty"`
}

type LinkExec struct {
	exec *prisma.Exec
}

func (instance *LinkExec) Map() *MapExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Map"},
		"map",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

func (instance LinkExec) Exec(ctx context.Context) (*Link, error) {
	var v Link
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkExecArray struct {
	exec *prisma.Exec
}

func (instance LinkExecArray) Exec(ctx context.Context) ([]Link, error) {
	var v []Link
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkFields = []string{"id", "source", "target"}

type Link struct {
	ID     string `json:"id"`
	Source string `json:"source"`
	Target string `json:"target"`
}

type KnotConnectionExec struct {
	exec *prisma.Exec
}

func (instance *KnotConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *KnotConnectionExec) Edges() *KnotEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"KnotWhereInput", "KnotOrderByInput", "KnotEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Knot"},
		"node",
		KnotFields)

	return &KnotEdgeExecArray{nodes}
}

func (instance *KnotConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateKnot"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance KnotConnectionExec) Exec(ctx context.Context) (*KnotConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &KnotConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance KnotConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KnotConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance KnotConnectionExecArray) Exec(ctx context.Context) ([]KnotConnection, error) {
	var v []KnotConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var KnotConnectionFields = []string{}

type KnotConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []KnotEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type KnotEdgeExec struct {
	exec *prisma.Exec
}

func (instance *KnotEdgeExec) Node() *KnotExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Knot"},
		"node",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExec{ret}
}

func (instance KnotEdgeExec) Exec(ctx context.Context) (*KnotEdge, error) {
	var v KnotEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KnotEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KnotEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance KnotEdgeExecArray) Exec(ctx context.Context) ([]KnotEdge, error) {
	var v []KnotEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var KnotEdgeFields = []string{"cursor"}

type KnotEdge struct {
	Node   Knot   `json:"node"`
	Cursor string `json:"cursor"`
}

type LinkConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LinkConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LinkConnectionExec) Edges() *LinkEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"LinkWhereInput", "LinkOrderByInput", "LinkEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Link"},
		"node",
		LinkFields)

	return &LinkEdgeExecArray{nodes}
}

func (instance *LinkConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLink"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance LinkConnectionExec) Exec(ctx context.Context) (*LinkConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &LinkConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance LinkConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LinkConnectionExecArray) Exec(ctx context.Context) ([]LinkConnection, error) {
	var v []LinkConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkConnectionFields = []string{}

type LinkConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []LinkEdge `json:"edges"`
}

type LinkEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LinkEdgeExec) Node() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"node",
		[]string{"id", "source", "target"})

	return &LinkExec{ret}
}

func (instance LinkEdgeExec) Exec(ctx context.Context) (*LinkEdge, error) {
	var v LinkEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LinkEdgeExecArray) Exec(ctx context.Context) ([]LinkEdge, error) {
	var v []LinkEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkEdgeFields = []string{"cursor"}

type LinkEdge struct {
	Node   Link   `json:"node"`
	Cursor string `json:"cursor"`
}

type LinkedAppConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LinkedAppConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LinkedAppConnectionExec) Edges() *LinkedAppEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"LinkedAppWhereInput", "LinkedAppOrderByInput", "LinkedAppEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "LinkedApp"},
		"node",
		LinkedAppFields)

	return &LinkedAppEdgeExecArray{nodes}
}

func (instance *LinkedAppConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLinkedApp"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance LinkedAppConnectionExec) Exec(ctx context.Context) (*LinkedAppConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &LinkedAppConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance LinkedAppConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkedAppConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LinkedAppConnectionExecArray) Exec(ctx context.Context) ([]LinkedAppConnection, error) {
	var v []LinkedAppConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkedAppConnectionFields = []string{}

type LinkedAppConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []LinkedAppEdge `json:"edges"`
}

type LinkedAppEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LinkedAppEdgeExec) Node() *LinkedAppExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkedApp"},
		"node",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExec{ret}
}

func (instance LinkedAppEdgeExec) Exec(ctx context.Context) (*LinkedAppEdge, error) {
	var v LinkedAppEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkedAppEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkedAppEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LinkedAppEdgeExecArray) Exec(ctx context.Context) ([]LinkedAppEdge, error) {
	var v []LinkedAppEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkedAppEdgeFields = []string{"cursor"}

type LinkedAppEdge struct {
	Node   LinkedApp `json:"node"`
	Cursor string    `json:"cursor"`
}

type MapConnectionExec struct {
	exec *prisma.Exec
}

func (instance *MapConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *MapConnectionExec) Edges() *MapEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"MapWhereInput", "MapOrderByInput", "MapEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Map"},
		"node",
		MapFields)

	return &MapEdgeExecArray{nodes}
}

func (instance *MapConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateMap"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance MapConnectionExec) Exec(ctx context.Context) (*MapConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &MapConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance MapConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MapConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance MapConnectionExecArray) Exec(ctx context.Context) ([]MapConnection, error) {
	var v []MapConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MapConnectionFields = []string{}

type MapConnection struct {
	PageInfo PageInfo  `json:"pageInfo"`
	Edges    []MapEdge `json:"edges"`
}

type MapEdgeExec struct {
	exec *prisma.Exec
}

func (instance *MapEdgeExec) Node() *MapExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Map"},
		"node",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

func (instance MapEdgeExec) Exec(ctx context.Context) (*MapEdge, error) {
	var v MapEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MapEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MapEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance MapEdgeExecArray) Exec(ctx context.Context) ([]MapEdge, error) {
	var v []MapEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MapEdgeFields = []string{"cursor"}

type MapEdge struct {
	Node   Map    `json:"node"`
	Cursor string `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type KnotSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *KnotSubscriptionPayloadExec) Node() *KnotExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Knot"},
		"node",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotExec{ret}
}

func (instance *KnotSubscriptionPayloadExec) PreviousValues() *KnotPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "KnotPreviousValues"},
		"previousValues",
		[]string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"})

	return &KnotPreviousValuesExec{ret}
}

func (instance KnotSubscriptionPayloadExec) Exec(ctx context.Context) (*KnotSubscriptionPayload, error) {
	var v KnotSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KnotSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KnotSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance KnotSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]KnotSubscriptionPayload, error) {
	var v []KnotSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var KnotSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type KnotSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Knot        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type KnotPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance KnotPreviousValuesExec) Exec(ctx context.Context) (*KnotPreviousValues, error) {
	var v KnotPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance KnotPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type KnotPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance KnotPreviousValuesExecArray) Exec(ctx context.Context) ([]KnotPreviousValues, error) {
	var v []KnotPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var KnotPreviousValuesFields = []string{"id", "trackId", "level", "visited", "createdAt", "updatedAt"}

type KnotPreviousValues struct {
	ID        string `json:"id"`
	TrackId   string `json:"trackId"`
	Level     int32  `json:"level"`
	Visited   bool   `json:"visited"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type LinkSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LinkSubscriptionPayloadExec) Node() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"node",
		[]string{"id", "source", "target"})

	return &LinkExec{ret}
}

func (instance *LinkSubscriptionPayloadExec) PreviousValues() *LinkPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkPreviousValues"},
		"previousValues",
		[]string{"id", "source", "target"})

	return &LinkPreviousValuesExec{ret}
}

func (instance LinkSubscriptionPayloadExec) Exec(ctx context.Context) (*LinkSubscriptionPayload, error) {
	var v LinkSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LinkSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LinkSubscriptionPayload, error) {
	var v []LinkSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type LinkSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Link        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LinkPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LinkPreviousValuesExec) Exec(ctx context.Context) (*LinkPreviousValues, error) {
	var v LinkPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LinkPreviousValuesExecArray) Exec(ctx context.Context) ([]LinkPreviousValues, error) {
	var v []LinkPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkPreviousValuesFields = []string{"id", "source", "target"}

type LinkPreviousValues struct {
	ID     string `json:"id"`
	Source string `json:"source"`
	Target string `json:"target"`
}

type LinkedAppSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LinkedAppSubscriptionPayloadExec) Node() *LinkedAppExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkedApp"},
		"node",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppExec{ret}
}

func (instance *LinkedAppSubscriptionPayloadExec) PreviousValues() *LinkedAppPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LinkedAppPreviousValues"},
		"previousValues",
		[]string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"})

	return &LinkedAppPreviousValuesExec{ret}
}

func (instance LinkedAppSubscriptionPayloadExec) Exec(ctx context.Context) (*LinkedAppSubscriptionPayload, error) {
	var v LinkedAppSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkedAppSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkedAppSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LinkedAppSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LinkedAppSubscriptionPayload, error) {
	var v []LinkedAppSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkedAppSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type LinkedAppSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *LinkedApp   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LinkedAppPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LinkedAppPreviousValuesExec) Exec(ctx context.Context) (*LinkedAppPreviousValues, error) {
	var v LinkedAppPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkedAppPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkedAppPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LinkedAppPreviousValuesExecArray) Exec(ctx context.Context) ([]LinkedAppPreviousValues, error) {
	var v []LinkedAppPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkedAppPreviousValuesFields = []string{"id", "type", "accessToken", "tokenExpiry", "refreshToken", "userId", "username"}

type LinkedAppPreviousValues struct {
	ID           string  `json:"id"`
	Type         AppType `json:"type"`
	AccessToken  *string `json:"accessToken,omitempty"`
	TokenExpiry  *string `json:"tokenExpiry,omitempty"`
	RefreshToken *string `json:"refreshToken,omitempty"`
	UserId       string  `json:"userId"`
	Username     *string `json:"username,omitempty"`
}

type MapSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *MapSubscriptionPayloadExec) Node() *MapExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Map"},
		"node",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapExec{ret}
}

func (instance *MapSubscriptionPayloadExec) PreviousValues() *MapPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MapPreviousValues"},
		"previousValues",
		[]string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"})

	return &MapPreviousValuesExec{ret}
}

func (instance MapSubscriptionPayloadExec) Exec(ctx context.Context) (*MapSubscriptionPayload, error) {
	var v MapSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MapSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MapSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance MapSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MapSubscriptionPayload, error) {
	var v []MapSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MapSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type MapSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Map         `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type MapPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance MapPreviousValuesExec) Exec(ctx context.Context) (*MapPreviousValues, error) {
	var v MapPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MapPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MapPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance MapPreviousValuesExecArray) Exec(ctx context.Context) ([]MapPreviousValues, error) {
	var v []MapPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MapPreviousValuesFields = []string{"id", "title", "flagshipId", "public", "createdAt", "updatedAt"}

type MapPreviousValues struct {
	ID         string  `json:"id"`
	Title      string  `json:"title"`
	FlagshipId *string `json:"flagshipId,omitempty"`
	Public     bool    `json:"public"`
	CreatedAt  string  `json:"createdAt"`
	UpdatedAt  string  `json:"updatedAt"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "username", "createdAt", "updatedAt"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "username", "createdAt", "updatedAt"}

type UserPreviousValues struct {
	ID        string  `json:"id"`
	Username  *string `json:"username,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}
